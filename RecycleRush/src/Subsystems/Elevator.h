// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef ELEVATOR_H
#define ELEVATOR_H
#include "Commands/Subsystem.h"
#include "WPILib.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class Elevator: public Subsystem {
private:
	// It's desirable that everything possible under private except
	// for methods that implement subsystem capabilities
public:
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	Encoder* shaftEncoder;
	SpeedController* motor;
	DigitalInput* lowerLimit;
	DigitalInput* upperLimit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	Elevator();
	float distanceBetweenLevels;
	float targetLevel; //Target 'Level' of lift, is theoretical encoder distance

const float kAutomatedStartSpeed = 0.1;	// Automated elevator movements start moving at this speed
const float kAutomatedMaxSpeed = 1.0;	// Automated elevator movements not to exceed this speed
const float kAccelerateDeceleratePercentPerInvocation = 0.60;	// Upon each invocation, apply this percent to the current speed
const float kAccelerateDecelerateEncoderCountRange = 20.0;	// If within this many encoder counts of start then apply acceleration, if within this many encoder counts of end then apply deceleration
float m_targetPosition;				// Encoder position we are attempting to move elevator to
float m_startingPosition;			// Encoder position when positioning command invoked
float m_direction;					// +1 for up, -1 for down. Based on initialization comparison of starting and target position
void StartMovingTowardTargetPosition(float TargetPosition);	// Save target position requested by command initialization; initialization of movement; and start moving
void StartMovingTowardLowerSafety();			//Moves towards lower safety
void MaxSpeedTowardsLowerSafety();			//Still moves towards lower safety
bool ReachedLowerSafety();					//To figure out when to stop moving
void StartMovingTowardTargetPositionWithPower(float TargetPosition, float MotorPower);	// Save target position requested by command initialization; initialization of movement; and start moving
void AccelerateMaxSpeedDecelerate();						// Continue movement but ramping up to, or down from, full speed
void AccelerateMaxSpeedDecelerateWithPower(float MotorPower);						// Continue movement but ramping up to, or down from, full speed
bool ReachedTargetPosition();								// True when elevator has reached or passed the target position
bool LowerSafetyIsCurrentlyPressed();						// Limit switch is currently wired to return false when pressed. We negate that and return true when pressed
bool UpperSafetyIsCurrentlyPressed();						// Limit switch is currently wired to return false when pressed. We negate that and return true when pressed

	void AddOneLevel();
	void SubtractOneLevel();

	float GetThrottle();
	float GetTargetLevel(float direction);
	void SetTargetLevel(float TargetLevel);
	float GetCurrentPosition();//'Position' should refer to actual encoder reading, while Level should used for theoretical/target positions
	void InitDefaultCommand();

	bool GetUpperSafety();
	bool GetLowerSafety();
	bool isMoving();
	bool isAboveTarget();
	bool isBelowTarget();
	float GetSpeed();

	void Start(float speed);
	void ManualControl();
	void SmartDashboardInputs();
	void SmartDashboardOutputs();
	void Stop();

	void RampUp( float MaxSpeed, float RampRate);
	void RampDown(  float MinSpeed, float RampRate);
	void RampCombined(float MinSpeed, float MaxSpeed, float RampRate);
	//These two functions are periodic and need to be continuously called to achieve the desired effect
	//This allows them to be interrupted

	//direction is -1 or 1, where 1 is the up direction



};

#endif
